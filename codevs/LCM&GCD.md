# LCM&GCD
---

LCM(A,B)×GCD(A,B)=A×B
其中LCM是最小公倍数，GCD是最大公约数

用代码来表示就是：

    // LCM:least common multiple
    // GCD:greatest common divisor
    int LCM(int a, int b) {
        int gcd = GCD(a, b);
        return a * b / gcd;
    }
**所以重点就是求最大公约数**

常见的求最大公约数的方法有

- 分解因式法
- 辗转相除法
- 更相减损法
- Stein算法
- 
##公约数的性质
在介绍算法之前，我们需要先了解一下公约数的几个重要性质，这几个性质在后面几个算法中会用到(用到时再证明，以免数学不感冒的人看的头痛)：

如果b是A和B的公约数，那么：

b也是A+B的约数，即b是A,B,A+B的公约数
b也是A-B的约数，即b是A,B,A-B的公约数
更一般地，对于任意整数x、y，b也是Ax+By的约数，即b是A,B,Ax+By的公约数
根据上一条性质，r = A - kB = A mod B，所以A mod B也是A+B的约数，mod是求余运算，即b是A,B,A mod B的公约数
用式子写出来即：

`gcd(A,B) = gcd(B,A) = gcd(A,A+B) = gcd(A,A-B) = gcd(A,Ax+By) = gcd(A,A mod B)`

##分解因式法
很显然因式分解不是一个好方法，看下面实现代码就知道很耗性能，而且还不能对0处理。

代码：
```
// greatest common divisor
int GCD(int a, int b) {
    assert(a != 0);
    assert(b != 0);
    int min = a < b ? a : b;
    int accumulate = 1;

    // 以2进行分解，如果0进来这里就死循环了
    while ((a & 1) == 0 && (b & 1) == 0) {
        accumulate *= 2;
        a >>= 1;
        b >>= 1;
    }
    // 以大于等于3的数进行分解
    for (int i = 3; i <= min; i += 2) {
        while ((a % i) == 0 && (b % i) == 0) {
          accumulate *= i;
          a /= i;
          b /= i;
        }
    }
    // 将所有公因子的乘积作为返回值
    return accumulate;
}
```
虽然暴力法代码冗长，性能低下，但对于后面的几个算法仍具有参考意义。

---
##辗转相除法(欧几里得算法)
**定义：**
辗转相除法(中国叫法)也叫欧几里得算法(国外叫法)。

该算法定义如下：两个正整数A，B的最大公约数等于其中较小值与两数相除的余数的最大公约数。

写成公式就是：

`gcd(A, B) = gcd(B, A mod B)   其中:A > B`

>证明
不妨设A > B，设A和B的最大公约数为X，所以 A=aX，B=bX，其中a和b都为正整数且a>b。

A除以B的余数： R = A - k*B，其中k为正整数是A除以B的商，所以： 

    `R=A−k∗B=aX−kbX=(a−kb)X>`

因为a、k、b均为正整数，所以R也能被X整除
即A、B、R的公约数相同，所以有`gcd(A，B) = gcd(B，A mod B)`

**代码：**
```
int GCD(int a, int b) {
    return b == 0 ? a : GCD(b, a%b);
}
```

**将递归化成循环：**
```
int GCD(int a, int b) {
    int r;
    while (b != 0) {
        r = a % b; a = b; b = r;
    }
    return a;
}
```
---
##更相减损法
**定义：**
*更相减损法原本是为了约分而设计的：可半者半之，不可半者，副置分母、子之数，以少减多，更相减损，求其等也。以等数约之。*

>1：任意给定两个正整数；判断它们是否都是偶数。若是，则用2约简；若不是则执行第二步。

>2：以较大的数减较小的数，接着把所得的差与较小的数比较，并以大数减小数。继续这个操作，直到所得的减数和差相等为止。

>第一步中约掉的若干个2与第二步中等数的乘积就是所求的最大公约数，相当于不要第一步。

换成公式的写法：

`如果A > B，则 gcd(A,B) = gcd(B,A-B)`
`如果A < B，则 gcd(A,B) = gcd(A,B-A)`
下面这张图是维基百科中对欧几里得算法的描述，但实际上这张图并没有直接求余数，而是两者相减，和更相减损法如出一辙。
![更相减损术][1]

>证明：
不妨设A>B，设A和B的最大公约数为X，所以 A=aX，B=bx，其中a和b都为正整数，切a>b。

>C = A-B，则有： 

>**C=aX−bX=(a−b)X>**

>因为a和b均为正整数，所以C也能被X整除，即A、B、C最大公约数均为X
所以gcd(A,B) = gcd(B,A-B)

代码实现：
```
int GCD(int a, int b) {
    while (a != b) {
        if (a > b)
            a = a - b;
        else
            b = b - a;
    }
    return a;
}
```
---
##辗转相除法与更相减损术的比较
1. 两者都是求最大公因数的方法，计算上辗转相除法以除法为主，更相减损术以减法为主，计算次数上辗转相除法计算次数相对较少，特别当两个数字大小区别较大时计算次数的区别较明显。

2. 从结果体现形式来看，辗转相除法体现结果是以相除余数为0则得到，而更相减损术则以减数与差相等而得到。
---

---
##Stein算法&扩展欧几里得算法
>这个局限于当前我的水平，暂且不写，之后补充